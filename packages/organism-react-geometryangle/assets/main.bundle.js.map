{"version":3,"file":"main.bundle.js","mappings":";;;;;;;;;;;;AAAA;AACA;AACA;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnXA;AACA;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACRA;AACA;AACA;AACA;AACA;;;;;ACJA;;;;;ACAA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;ACJA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AErFA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://organism-react-geometryangle/./build/es/src/client.mjs","webpack://organism-react-geometryangle/./build/es/src/fss.mjs","webpack://organism-react-geometryangle/./build/es/src/fss_worker.mjs","webpack://organism-react-geometryangle/./build/es/src/index.mjs","webpack://organism-react-geometryangle/./build/es/src/ui/organisms/GeometryAngle.mjs","webpack://organism-react-geometryangle/./build/es/src/ui/pages/index.mjs","webpack://organism-react-geometryangle/webpack/bootstrap","webpack://organism-react-geometryangle/webpack/runtime/chunk loaded","webpack://organism-react-geometryangle/webpack/runtime/compat get default export","webpack://organism-react-geometryangle/webpack/runtime/define property getters","webpack://organism-react-geometryangle/webpack/runtime/ensure chunk","webpack://organism-react-geometryangle/webpack/runtime/get javascript chunk filename","webpack://organism-react-geometryangle/webpack/runtime/getFullHash","webpack://organism-react-geometryangle/webpack/runtime/hasOwnProperty shorthand","webpack://organism-react-geometryangle/webpack/runtime/load script","webpack://organism-react-geometryangle/webpack/runtime/make namespace object","webpack://organism-react-geometryangle/webpack/runtime/node module decorator","webpack://organism-react-geometryangle/webpack/runtime/publicPath","webpack://organism-react-geometryangle/webpack/runtime/react refresh","webpack://organism-react-geometryangle/webpack/runtime/jsonp chunk loading","webpack://organism-react-geometryangle/webpack/before-startup","webpack://organism-react-geometryangle/webpack/startup","webpack://organism-react-geometryangle/webpack/after-startup"],"sourcesContent":["import client from \"reshow-app/client\";\nimport app from \"./ui/pages/index.mjs\";\nexport default client(app);\n","function _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\n/**\n * @type object\n */ var FSS = {\n    FRONT: 0,\n    BACK: 1,\n    DOUBLE: 2,\n    SVGNS: \"http://www.w3.org/2000/svg\"\n};\n/**\n * @class Array\n * @author Matthew Wagerfield\n */ FSS.Array = typeof Float32Array === \"function\" ? Float32Array : Array;\n/**\n * @class Utils\n * @author Matthew Wagerfield\n */ FSS.Utils = {\n    isNumber: function isNumber(value) {\n        return !isNaN(parseFloat(value)) && isFinite(value);\n    }\n};\n/**\n * Request Animation Frame Polyfill.\n * @author Paul Irish\n * @see https://gist.github.com/paulirish/1579671\n */ /**\n * @object Math Augmentation\n * @author Matthew Wagerfield\n */ Math.PIM2 = Math.PI * 2;\nMath.PID2 = Math.PI / 2;\nMath.randomInRange = function(min, max) {\n    return min + (max - min) * Math.random();\n};\nMath.clamp = function(value, min, max) {\n    value = Math.max(value, min);\n    value = Math.min(value, max);\n    return value;\n};\n/**\n * @object Vector3\n * @author Matthew Wagerfield\n */ FSS.Vector3 = {\n    create: function create(x, y, z) {\n        var vector = new FSS.Array(3);\n        this.set(vector, x, y, z);\n        return vector;\n    },\n    clone: function clone(a) {\n        var vector = this.create();\n        this.copy(vector, a);\n        return vector;\n    },\n    set: function set(target, x, y, z) {\n        target[0] = x || 0;\n        target[1] = y || 0;\n        target[2] = z || 0;\n        return this;\n    },\n    setX: function setX(target, x) {\n        target[0] = x || 0;\n        return this;\n    },\n    setY: function setY(target, y) {\n        target[1] = y || 0;\n        return this;\n    },\n    setZ: function setZ(target, z) {\n        target[2] = z || 0;\n        return this;\n    },\n    copy: function copy(target, a) {\n        target[0] = a[0];\n        target[1] = a[1];\n        target[2] = a[2];\n        return this;\n    },\n    add: function add(target, a) {\n        target[0] += a[0];\n        target[1] += a[1];\n        target[2] += a[2];\n        return this;\n    },\n    addVectors: function addVectors(target, a, b) {\n        target[0] = a[0] + b[0];\n        target[1] = a[1] + b[1];\n        target[2] = a[2] + b[2];\n        return this;\n    },\n    addScalar: function addScalar(target, s) {\n        target[0] += s;\n        target[1] += s;\n        target[2] += s;\n        return this;\n    },\n    subtract: function subtract(target, a) {\n        target[0] -= a[0];\n        target[1] -= a[1];\n        target[2] -= a[2];\n        return this;\n    },\n    subtractVectors: function subtractVectors(target, a, b) {\n        target[0] = a[0] - b[0];\n        target[1] = a[1] - b[1];\n        target[2] = a[2] - b[2];\n        return this;\n    },\n    subtractScalar: function subtractScalar(target, s) {\n        target[0] -= s;\n        target[1] -= s;\n        target[2] -= s;\n        return this;\n    },\n    multiply: function multiply(target, a) {\n        target[0] *= a[0];\n        target[1] *= a[1];\n        target[2] *= a[2];\n        return this;\n    },\n    multiplyVectors: function multiplyVectors(target, a, b) {\n        target[0] = a[0] * b[0];\n        target[1] = a[1] * b[1];\n        target[2] = a[2] * b[2];\n        return this;\n    },\n    multiplyScalar: function multiplyScalar(target, s) {\n        target[0] *= s;\n        target[1] *= s;\n        target[2] *= s;\n        return this;\n    },\n    divide: function divide(target, a) {\n        target[0] /= a[0];\n        target[1] /= a[1];\n        target[2] /= a[2];\n        return this;\n    },\n    divideVectors: function divideVectors(target, a, b) {\n        target[0] = a[0] / b[0];\n        target[1] = a[1] / b[1];\n        target[2] = a[2] / b[2];\n        return this;\n    },\n    divideScalar: function divideScalar(target, s) {\n        if (s !== 0) {\n            target[0] /= s;\n            target[1] /= s;\n            target[2] /= s;\n        } else {\n            target[0] = 0;\n            target[1] = 0;\n            target[2] = 0;\n        }\n        return this;\n    },\n    cross: function cross(target, a) {\n        var x = target[0];\n        var y = target[1];\n        var z = target[2];\n        target[0] = y * a[2] - z * a[1];\n        target[1] = z * a[0] - x * a[2];\n        target[2] = x * a[1] - y * a[0];\n        return this;\n    },\n    crossVectors: function crossVectors(target, a, b) {\n        target[0] = a[1] * b[2] - a[2] * b[1];\n        target[1] = a[2] * b[0] - a[0] * b[2];\n        target[2] = a[0] * b[1] - a[1] * b[0];\n        return this;\n    },\n    min: function min(target, value) {\n        if (target[0] < value) {\n            target[0] = value;\n        }\n        if (target[1] < value) {\n            target[1] = value;\n        }\n        if (target[2] < value) {\n            target[2] = value;\n        }\n        return this;\n    },\n    max: function max(target, value) {\n        if (target[0] > value) {\n            target[0] = value;\n        }\n        if (target[1] > value) {\n            target[1] = value;\n        }\n        if (target[2] > value) {\n            target[2] = value;\n        }\n        return this;\n    },\n    clamp: function clamp(target, min, max) {\n        this.min(target, min);\n        this.max(target, max);\n        return this;\n    },\n    limit: function limit(target, min, max) {\n        var length = this.length(target);\n        if (min !== null && length < min) {\n            this.setLength(target, min);\n        } else if (max !== null && length > max) {\n            this.setLength(target, max);\n        }\n        return this;\n    },\n    dot: function dot(a, b) {\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    },\n    normalise: function normalise(target) {\n        return this.divideScalar(target, this.length(target));\n    },\n    negate: function negate(target) {\n        return this.multiplyScalar(target, -1);\n    },\n    distanceSquared: function distanceSquared(a, b) {\n        var dx = a[0] - b[0];\n        var dy = a[1] - b[1];\n        var dz = a[2] - b[2];\n        return dx * dx + dy * dy + dz * dz;\n    },\n    distance: function distance(a, b) {\n        return Math.sqrt(this.distanceSquared(a, b));\n    },\n    lengthSquared: function lengthSquared(a) {\n        return a[0] * a[0] + a[1] * a[1] + a[2] * a[2];\n    },\n    length: function length(a) {\n        return Math.sqrt(this.lengthSquared(a));\n    },\n    setLength: function setLength(target, l) {\n        var length = this.length(target);\n        if (length !== 0 && l !== length) {\n            this.multiplyScalar(target, l / length);\n        }\n        return this;\n    },\n    floor: function floor(target) {\n        target[0] = Math.floor(target[0]);\n        target[1] = Math.floor(target[1]);\n        target[2] = Math.floor(target[2]);\n        return target;\n    }\n};\n/**\n * @object Vector4\n * @author Matthew Wagerfield\n */ FSS.Vector4 = {\n    create: function create(x, y, z, w) {\n        var vector = new FSS.Array(4);\n        this.set(vector, x, y, z);\n        return vector;\n    },\n    set: function set(target, x, y, z, w) {\n        target[0] = x || 0;\n        target[1] = y || 0;\n        target[2] = z || 0;\n        target[3] = w || 0;\n        return this;\n    },\n    setX: function setX(target, x) {\n        target[0] = x || 0;\n        return this;\n    },\n    setY: function setY(target, y) {\n        target[1] = y || 0;\n        return this;\n    },\n    setZ: function setZ(target, z) {\n        target[2] = z || 0;\n        return this;\n    },\n    setW: function setW(target, w) {\n        target[3] = w || 0;\n        return this;\n    },\n    add: function add(target, a) {\n        target[0] += a[0];\n        target[1] += a[1];\n        target[2] += a[2];\n        target[3] += a[3];\n        return this;\n    },\n    multiplyVectors: function multiplyVectors(target, a, b) {\n        target[0] = a[0] * b[0];\n        target[1] = a[1] * b[1];\n        target[2] = a[2] * b[2];\n        target[3] = a[3] * b[3];\n        return this;\n    },\n    multiplyScalar: function multiplyScalar(target, s) {\n        target[0] *= s;\n        target[1] *= s;\n        target[2] *= s;\n        target[3] *= s;\n        return this;\n    },\n    min: function min(target, value) {\n        if (target[0] < value) {\n            target[0] = value;\n        }\n        if (target[1] < value) {\n            target[1] = value;\n        }\n        if (target[2] < value) {\n            target[2] = value;\n        }\n        if (target[3] < value) {\n            target[3] = value;\n        }\n        return this;\n    },\n    max: function max(target, value) {\n        if (target[0] > value) {\n            target[0] = value;\n        }\n        if (target[1] > value) {\n            target[1] = value;\n        }\n        if (target[2] > value) {\n            target[2] = value;\n        }\n        if (target[3] > value) {\n            target[3] = value;\n        }\n        return this;\n    },\n    clamp: function clamp(target, min, max) {\n        this.min(target, min);\n        this.max(target, max);\n        return this;\n    }\n};\n/**\n * @class Color\n * @author Matthew Wagerfield\n */ FSS.Color = function(color, opacity1) {\n    this.rgba = [];\n    this.color = color || \"#000000\";\n    this.opacity = FSS.Utils.isNumber(opacity1) ? opacity1 : 1;\n    this.set(this.color, this.opacity);\n};\nFSS.Color.prototype = {\n    set: function set(color, opacity2) {\n        if (color.indexOf(\"#\") === -1) {\n            if (color.indexOf(\"rgb(\") === 0) {\n                var pars = color.indexOf(\",\");\n                this.rgba[0] = parseInt(color.substr(4, pars));\n                this.rgba[1] = parseInt(color.substr(pars + 1, color.indexOf(\",\", pars)));\n                this.rgba[2] = parseInt(color.substr(color.indexOf(\",\", pars + 1) + 1, color.indexOf(\")\")));\n                this.rgba[3] = 1;\n            } else if (color.indexOf(\"rgba(\") === 0) {\n                var pars = color.indexOf(\",\");\n                var repars = color.indexOf(\",\", pars + 1);\n                this.rgba[0] = parseInt(color.substr(5, pars));\n                this.rgba[1] = parseInt(color.substr(pars + 1, repars));\n                this.rgba[2] = parseInt(color.substr(color.indexOf(\",\", pars + 1) + 1, color.indexOf(\",\", repars)));\n                this.rgba[3] = parseFloat(color.substr(color.indexOf(\",\", repars + 1) + 1, color.indexOf(\")\")));\n            }\n        } else {\n            color = color.replace(\"#\", \"\");\n            var size = color.length / 3;\n            this.rgba[0] = parseInt(color.substring(size * 0, size * 1), 16) / 255;\n            this.rgba[1] = parseInt(color.substring(size * 1, size * 2), 16) / 255;\n            this.rgba[2] = parseInt(color.substring(size * 2, size * 3), 16) / 255;\n            this.rgba[3] = FSS.Utils.isNumber(opacity2) ? opacity2 : this.rgba[3];\n        }\n        return this;\n    },\n    //    hexify: function (channel) {\n    //        var hex = Math.ceil(channel * 255).toString(16);\n    //        if (hex.length === 1) {\n    //            hex = '0' + hex;\n    //        }\n    //        return hex;\n    //    },\n    format: function format() {\n        return \"rgba(\" + this.rgba[0] + \",\" + this.rgba[1] + \",\" + this.rgba[2] + \",\" + this.rgba[3] + \")\"; //this.hex\n    //        var r = this.hexify(this.rgba[0]);\n    //        var g = this.hexify(this.rgba[1]);\n    //        var b = this.hexify(this.rgba[2]);\n    //        this.hex = '#' + r + g + b;\n    //        return this.hex;\n    }\n};\n/**\n * @class Object\n * @author Matthew Wagerfield\n */ FSS.Object = function() {\n    this.position = FSS.Vector3.create();\n};\nFSS.Object.prototype = {\n    setPosition: function setPosition(x, y, z) {\n        FSS.Vector3.set(this.position, x, y, z);\n        return this;\n    }\n};\n/**\n * @class Light\n * @author Matthew Wagerfield\n */ FSS.Light = function(ambient, diffuse) {\n    FSS.Object.call(this);\n    this.ambient = new FSS.Color(ambient || \"#FFFFFF\");\n    this.diffuse = new FSS.Color(diffuse || \"#FFFFFF\");\n    this.ray = FSS.Vector3.create();\n};\nFSS.Light.prototype = Object.create(FSS.Object.prototype);\n/**\n * @class Vertex\n * @author Matthew Wagerfield\n */ FSS.Vertex = function(x, y, z) {\n    this.position = FSS.Vector3.create(x, y, z);\n};\nFSS.Vertex.prototype = {\n    setPosition: function setPosition(x, y, z) {\n        FSS.Vector3.set(this.position, x, y, z);\n        return this;\n    }\n};\n/**\n * @class Triangle\n * @author Matthew Wagerfield\n */ FSS.Triangle = function(a, b, c) {\n    this.a = a || new FSS.Vertex();\n    this.b = b || new FSS.Vertex();\n    this.c = c || new FSS.Vertex();\n    this.vertices = [\n        this.a,\n        this.b,\n        this.c\n    ];\n    this.u = FSS.Vector3.create();\n    this.v = FSS.Vector3.create();\n    this.centroid = FSS.Vector3.create();\n    this.normal = FSS.Vector3.create();\n    this.color = new FSS.Color();\n    this.polygon = document.createElementNS(FSS.SVGNS, \"polygon\");\n    this.polygon.setAttributeNS(null, \"stroke-linejoin\", \"round\");\n    this.polygon.setAttributeNS(null, \"stroke-miterlimit\", \"1\");\n    this.polygon.setAttributeNS(null, \"stroke-width\", \"1\");\n    this.computeCentroid();\n    this.computeNormal();\n};\nFSS.Triangle.prototype = {\n    computeCentroid: function computeCentroid() {\n        this.centroid[0] = this.a.position[0] + this.b.position[0] + this.c.position[0];\n        this.centroid[1] = this.a.position[1] + this.b.position[1] + this.c.position[1];\n        this.centroid[2] = this.a.position[2] + this.b.position[2] + this.c.position[2];\n        FSS.Vector3.divideScalar(this.centroid, 3);\n        return this;\n    },\n    computeNormal: function computeNormal() {\n        FSS.Vector3.subtractVectors(this.u, this.b.position, this.a.position);\n        FSS.Vector3.subtractVectors(this.v, this.c.position, this.a.position);\n        FSS.Vector3.crossVectors(this.normal, this.u, this.v);\n        FSS.Vector3.normalise(this.normal);\n        return this;\n    }\n};\n/**\n * @class Geometry\n * @author Matthew Wagerfield\n */ FSS.Geometry = function() {\n    this.vertices = [];\n    this.triangles = [];\n    this.dirty = false;\n};\nFSS.Geometry.prototype = {\n    update: function update() {\n        if (this.dirty) {\n            var t, triangle;\n            for(t = this.triangles.length - 1; t >= 0; t--){\n                triangle = this.triangles[t];\n                triangle.computeCentroid();\n                triangle.computeNormal();\n            }\n            this.dirty = false;\n        }\n        return this;\n    }\n};\n/**\n * @class Plane\n * @author Matthew Wagerfield\n */ FSS.Plane = function(width, height, segments, slices) {\n    FSS.Geometry.call(this);\n    this.width = width || 100;\n    this.height = height || 100;\n    this.segments = segments || 4;\n    this.slices = slices || 4;\n    this.segmentWidth = this.width / this.segments;\n    this.sliceHeight = this.height / this.slices;\n    // Cache Variables\n    var x, y, v0, v1, v2, v3, vertex, triangle, vertices = [], offsetX = this.width * -0.5, offsetY = this.height * 0.5;\n    // Add Vertices\n    for(x = 0; x <= this.segments; x++){\n        vertices.push([]);\n        for(y = 0; y <= this.slices; y++){\n            vertex = new FSS.Vertex(offsetX + x * this.segmentWidth, offsetY - y * this.sliceHeight);\n            vertices[x].push(vertex);\n            this.vertices.push(vertex);\n        }\n    }\n    // Add Triangles\n    var t0;\n    var t1;\n    for(x = 0; x < this.segments; x++){\n        for(y = 0; y < this.slices; y++){\n            v0 = vertices[x + 0][y + 0];\n            v1 = vertices[x + 0][y + 1];\n            v2 = vertices[x + 1][y + 0];\n            v3 = vertices[x + 1][y + 1];\n            t0 = new FSS.Triangle(v0, v1, v2);\n            t1 = new FSS.Triangle(v2, v1, v3);\n            this.triangles.push(t0, t1);\n        }\n    }\n};\nFSS.Plane.prototype = Object.create(FSS.Geometry.prototype);\n/**\n * @class Material\n * @author Matthew Wagerfield\n */ FSS.Material = function(ambient, diffuse) {\n    this.ambient = new FSS.Color(ambient || \"rgba(68,68,68, 1)\");\n    this.diffuse = new FSS.Color(diffuse || \"rgba(255,255,255, 1)\");\n    this.slave = new FSS.Color();\n};\n/**\n * @class Mesh\n * @author Matthew Wagerfield\n */ FSS.Mesh = function(geometry, material) {\n    FSS.Object.call(this);\n    this.geometry = geometry || new FSS.Geometry();\n    this.material = material || new FSS.Material();\n    this.side = FSS.FRONT;\n    this.visible = true;\n};\nFSS.Mesh.prototype = Object.create(FSS.Object.prototype);\nFSS.Mesh.prototype.update = function(lights, calculate) {\n    var t, triangle, l, light, illuminance, light_count;\n    light_count = lights.length;\n    // Update Geometry\n    this.geometry.update();\n    // Calculate the triangle colors\n    if (calculate) {\n        // Iterate through Triangles\n        for(t = this.geometry.triangles.length - 1; t >= 0; t--){\n            triangle = this.geometry.triangles[t];\n            // Reset Triangle Color\n            FSS.Vector4.set(triangle.color.rgba);\n            // Iterate through Lights\n            for(l = lights.length - 1; l >= 0; l--){\n                light = lights[l];\n                // Calculate Illuminance\n                FSS.Vector3.subtractVectors(light.ray, light.position, triangle.centroid);\n                FSS.Vector3.normalise(light.ray);\n                illuminance = FSS.Vector3.dot(triangle.normal, light.ray);\n                if (this.side === FSS.FRONT) {\n                    illuminance = Math.max(illuminance, 0);\n                } else if (this.side === FSS.BACK) {\n                    illuminance = Math.abs(Math.min(illuminance, 0));\n                } else if (this.side === FSS.DOUBLE) {\n                    illuminance = Math.max(Math.abs(illuminance), 0);\n                }\n                //               Calculate Ambient Light\n                for(var i = 0; i < 3; i++){\n                    this.material.slave.rgba[i] = 1 / light_count * this.material.ambient.rgba[i] * (1 / light_count * light.ambient.rgba[i]) / 128;\n                    if (i !== 3) {\n                        this.material.slave.rgba[i] = Math.round(this.material.slave.rgba[i]);\n                    }\n                }\n                /* \t\t\t\tAdd the resultant values to the triangle color vector. Not required to factor illuminance because it is ambient light. */ FSS.Vector4.add(triangle.color.rgba, this.material.slave.rgba);\n                // Calculate Diffuse Light\n                for(var i = 0; i < 3; i++){\n                    this.material.slave.rgba[i] = 1 / light_count * this.material.diffuse.rgba[i] * (1 / light_count) * light.diffuse.rgba[i] / 128;\n                    if (i !== 3) {\n                        this.material.slave.rgba[i] = Math.round(this.material.slave.rgba[i]);\n                    }\n                }\n                //              FSS.Vector4.multiplyVectors(this.material.slave.rgba, this.material.diffuse.rgba, light.diffuse.rgba);\n                //              FSS.Vector4.multiplyScalar(this.material.slave.rgba, illuminance);\n                for(var i = 0; i < 3; i++){\n                    this.material.slave.rgba[i] = Math.round(this.material.slave.rgba[i] * illuminance);\n                }\n                FSS.Vector4.add(triangle.color.rgba, this.material.slave.rgba);\n            }\n            // Clamp & Format Color\n            FSS.Vector4.clamp(triangle.color.rgba, 0, 255);\n            triangle.color.rgba[3] = this.material.diffuse.rgba[3]; //Math.min(triangle.color.rgba[3], 1);\n        }\n    }\n    return this;\n};\n/**\n * @class Scene\n * @author Matthew Wagerfield\n */ FSS.Scene = function() {\n    this.meshes = [];\n    this.lights = [];\n};\nFSS.Scene.prototype = {\n    add: function add(object) {\n        if (_instanceof(object, FSS.Mesh) && !~this.meshes.indexOf(object)) {\n            this.meshes.push(object);\n        } else if (_instanceof(object, FSS.Light) && !~this.lights.indexOf(object)) {\n            this.lights.push(object);\n        }\n        return this;\n    },\n    remove: function remove(object) {\n        if (_instanceof(object, FSS.Mesh) && ~this.meshes.indexOf(object)) {\n            this.meshes.splice(this.meshes.indexOf(object), 1);\n        } else if (_instanceof(object, FSS.Light) && ~this.lights.indexOf(object)) {\n            this.lights.splice(this.lights.indexOf(object), 1);\n        }\n        return this;\n    }\n};\n/**\n * @class Renderer\n * @author Matthew Wagerfield\n */ FSS.Renderer = function() {\n    this.width = 0;\n    this.height = 0;\n    this.halfWidth = 0;\n    this.halfHeight = 0;\n};\nFSS.Renderer.prototype = {\n    setSize: function setSize(width, height) {\n        if (this.width === width && this.height === height) return;\n        this.width = width;\n        this.height = height;\n        this.halfWidth = this.width * 0.5;\n        this.halfHeight = this.height * 0.5;\n        return this;\n    },\n    clear: function clear() {\n        return this;\n    },\n    render: function render(scene) {\n        return this;\n    }\n};\n/**\n * @class Canvas Renderer\n * @author Matthew Wagerfield\n */ FSS.CanvasRenderer = function() {\n    FSS.Renderer.call(this);\n    this.element = document.createElement(\"canvas\");\n    /* \tthis.element.style.display = 'block'; */ this.element.style.zIndex = \"-100\";\n    this.element.style.pointerEvents = \"none\";\n    this.context = this.element.getContext(\"2d\");\n    this.setSize(this.element.width, this.element.height);\n};\nFSS.CanvasRenderer.prototype = Object.create(FSS.Renderer.prototype);\nFSS.CanvasRenderer.prototype.setSize = function(width, height) {\n    var _this$context;\n    FSS.Renderer.prototype.setSize.call(this, width, height);\n    this.element.width = width;\n    this.element.height = height;\n    (_this$context = this.context) === null || _this$context === void 0 ? void 0 : _this$context.setTransform(1, 0, 0, 1, 0, 0);\n    return this;\n};\nFSS.CanvasRenderer.prototype.clear = function() {\n    var _this$context2;\n    FSS.Renderer.prototype.clear.call(this);\n    (_this$context2 = this.context) === null || _this$context2 === void 0 ? void 0 : _this$context2.clearRect(0, 0, this.width, this.height);\n    return this;\n};\nvar opacity = [];\nFSS.CanvasRenderer.prototype.render = function(scene) {\n    FSS.Renderer.prototype.render.call(this, scene);\n    var m, mesh, t, triangle, color;\n    var pi2 = 2 * Math.PI;\n    // Clear Context\n    this.clear();\n    // Configure Context\n    if (null == this.context) {\n        return;\n    }\n    this.context.lineJoin = \"round\";\n    this.context.lineWidth = 0;\n    // Update Meshes\n    for(m = scene.meshes.length - 1; m >= 0; m--){\n        mesh = scene.meshes[m];\n        if (typeof opacity[m] == \"undefined\") {\n            opacity[m] = [];\n        }\n        if (mesh.visible) {\n            mesh.update(scene.lights, true);\n            // Render Triangles\n            for(t = mesh.geometry.triangles.length - 1; t >= 0; t--){\n                var now = Date.now();\n                if (typeof opacity[m][t] === \"undefined\") {\n                    opacity[m][t] = {};\n                    opacity[m][t].step = FSS.Vector3.create(Math.randomInRange(0.2, 1.0), Math.randomInRange(0.2, 1.0), Math.randomInRange(0.2, 1.0));\n                    opacity[m][t].time = Math.randomInRange(0, Math.PIM2);\n                    opacity[m][t].line = 0;\n                } else {\n                    opacity[m][t].line = Math.sin(opacity[m][t].time + opacity[m][t].step[0] * now * (scene.LINE.fluctuationSpeed / 100)) * scene.LINE.fluctuationIntensity;\n                    opacity[m][t].vertex = Math.sin(opacity[m][t].time + opacity[m][t].step[0] * now * (scene.VERTEX.fluctuationSpeed / 100)) * scene.VERTEX.fluctuationIntensity;\n                    opacity[m][t].mesh = Math.sin(opacity[m][t].time + opacity[m][t].step[0] * now * (scene.MESH.fluctuationSpeed / 100)) * scene.MESH.fluctuationIntensity;\n                }\n                triangle = mesh.geometry.triangles[t];\n                if (scene.MESH.draw !== false) {\n                    c = triangle.color.rgba;\n                    color = \"rgba(\" + c[0] + \",\" + c[1] + \", \" + c[2] + \",\" + c[3] + \")\";\n                    this.context.beginPath();\n                    this.context.moveTo(triangle.a.position[0], triangle.a.position[1]);\n                    this.context.lineTo(triangle.b.position[0], triangle.b.position[1]);\n                    this.context.lineTo(triangle.c.position[0], triangle.c.position[1]);\n                    this.context.closePath();\n                    this.context.fillStyle = color; //Color of triangle\n                    this.context.fill();\n                }\n                if (scene.LINE.draw !== false) {\n                    var c = new FSS.Color(scene.LINE.fill);\n                    c = c.rgba;\n                    c[3] = c[3] * (1 - opacity[m][t].line);\n                    c = \"rgba(\" + c[0] + \",\" + c[1] + \", \" + c[2] + \",\" + c[3] + \")\";\n                    this.context.beginPath();\n                    this.context.moveTo(triangle.a.position[0], triangle.a.position[1]);\n                    this.context.lineTo(triangle.b.position[0], triangle.b.position[1]);\n                    this.context.lineWidth = scene.LINE.thickness;\n                    this.context.fillStyle = c;\n                    this.context.fill();\n                    this.context.strokeStyle = c;\n                    this.context.stroke();\n                }\n                if (scene.VERTEX.draw !== false) {\n                    //                    var grd = this.context.createRadialGradient(triangle.a.position[0], triangle.a.position[1], scene.vertex.radius + 100, triangle.a.position[0], triangle.a.position[1], scene.vertex.radius + 105);\n                    // light blue\n                    //                    grd.addColorStop(0, '#8ED6FF');\n                    // dark blue\n                    //                    grd.addColorStop(1, '#004CB3');\n                    var c = new FSS.Color(scene.VERTEX.fill);\n                    c = c.rgba;\n                    c[3] = c[3] * (1 - opacity[m][t].vertex);\n                    c = \"rgba(\" + c[0] + \",\" + c[1] + \", \" + c[2] + \",\" + c[3] + \")\";\n                    var c1 = new FSS.Color(scene.VERTEX.strokeColor);\n                    c1 = c1.rgba;\n                    c1[3] = c1[3] * (1 - opacity[m][t].vertex);\n                    c1 = \"rgba(\" + c1[0] + \",\" + c1[1] + \", \" + c1[2] + \",\" + c1[3] + \")\";\n                    this.context.beginPath();\n                    this.context.arc(triangle.a.position[0], triangle.a.position[1], scene.VERTEX.radius, 0, pi2, false);\n                    this.context.fillStyle = c; //scene.VERTEX.fill;\n                    this.context.fill();\n                    this.context.lineWidth = scene.VERTEX.strokeWidth;\n                    this.context.strokeStyle = c1;\n                    this.context.stroke();\n                }\n            }\n        }\n    }\n    return this;\n};\n/**\n * @class WebGL Renderer\n * @author Matthew Wagerfield\n */ FSS.WebGLRenderer = function() {\n    FSS.Renderer.call(this);\n    this.element = document.createElement(\"canvas\");\n    this.element.style.display = \"block\";\n    // Set initial vertex and light count\n    this.vertices = null;\n    this.lights = null;\n    // Create parameters object\n    var parameters = {\n        preserveDrawingBuffer: false,\n        premultipliedAlpha: true,\n        antialias: true,\n        stencil: true,\n        alpha: true\n    };\n    // Create and configure the gl context\n    this.gl = this.getContext(this.element, parameters);\n    // Set the internal support flag\n    this.unsupported = !this.gl;\n    // Setup renderer\n    if (this.unsupported) {\n        return \"WebGL is not supported by your browser.\";\n    } else {\n        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);\n        this.gl.enable(this.gl.DEPTH_TEST);\n        this.setSize(this.element.width, this.element.height);\n    }\n};\nFSS.WebGLRenderer.prototype = Object.create(FSS.Renderer.prototype);\nFSS.WebGLRenderer.prototype.getContext = function(canvas, parameters) {\n    var context = false;\n    try {\n        if (!(context = canvas.getContext(\"experimental-webgl\", parameters))) {\n            throw \"Error creating WebGL context.\";\n        }\n    } catch (error) {\n        console.error(error);\n    }\n    return context;\n};\nFSS.WebGLRenderer.prototype.setSize = function(width, height) {\n    FSS.Renderer.prototype.setSize.call(this, width, height);\n    if (this.unsupported) return;\n    // Set the size of the canvas element\n    this.element.width = width;\n    this.element.height = height;\n    // Set the size of the gl viewport\n    this.gl.viewport(0, 0, width, height);\n    return this;\n};\nFSS.WebGLRenderer.prototype.clear = function() {\n    FSS.Renderer.prototype.clear.call(this);\n    if (this.unsupported) return;\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n    return this;\n};\nFSS.WebGLRenderer.prototype.render = function(scene) {\n    FSS.Renderer.prototype.render.call(this, scene);\n    if (this.unsupported) return;\n    var m, mesh, t, tl, triangle, l, light, attribute, uniform, buffer, data, location, update = false, lights = scene.lights.length, index, v, vl, vetex, vertices = 0;\n    // Clear context\n    this.clear();\n    // Build the shader program\n    if (this.lights !== lights) {\n        this.lights = lights;\n        if (this.lights > 0) {\n            this.buildProgram(lights);\n        } else {\n            return;\n        }\n    }\n    // Update program\n    if (!!this.program) {\n        // Increment vertex counter\n        for(m = scene.meshes.length - 1; m >= 0; m--){\n            mesh = scene.meshes[m];\n            if (mesh.geometry.dirty) update = true;\n            mesh.update(scene.lights, false);\n            vertices += mesh.geometry.triangles.length * 3;\n        }\n        // Compare vertex counter\n        if (update || this.vertices !== vertices) {\n            this.vertices = vertices;\n            // Build buffers\n            for(attribute in this.program.attributes){\n                buffer = this.program.attributes[attribute];\n                buffer.data = new FSS.Array(vertices * buffer.size);\n                // Reset vertex index\n                index = 0;\n                // Update attribute buffer data\n                var vertex = void 0;\n                for(m = scene.meshes.length - 1; m >= 0; m--){\n                    mesh = scene.meshes[m];\n                    for(t = 0, tl = mesh.geometry.triangles.length; t < tl; t++){\n                        triangle = mesh.geometry.triangles[t];\n                        for(v = 0, vl = triangle.vertices.length; v < vl; v++){\n                            vertex = triangle.vertices[v];\n                            switch(attribute){\n                                case \"side\":\n                                    this.setBufferData(index, buffer, mesh.side);\n                                    break;\n                                case \"position\":\n                                    this.setBufferData(index, buffer, vertex.position);\n                                    break;\n                                case \"centroid\":\n                                    this.setBufferData(index, buffer, triangle.centroid);\n                                    break;\n                                case \"normal\":\n                                    this.setBufferData(index, buffer, triangle.normal);\n                                    break;\n                                case \"ambient\":\n                                    this.setBufferData(index, buffer, mesh.material.ambient.rgba);\n                                    break;\n                                case \"diffuse\":\n                                    this.setBufferData(index, buffer, mesh.material.diffuse.rgba);\n                                    break;\n                            }\n                            index++;\n                        }\n                    }\n                }\n                // Upload attribute buffer data\n                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer.buffer);\n                this.gl.bufferData(this.gl.ARRAY_BUFFER, buffer.data, this.gl.DYNAMIC_DRAW);\n                this.gl.enableVertexAttribArray(buffer.location);\n                this.gl.vertexAttribPointer(buffer.location, buffer.size, this.gl.FLOAT, false, 0, 0);\n            }\n        }\n        // Build uniform buffers\n        this.setBufferData(0, this.program.uniforms.resolution, [\n            this.width,\n            this.height,\n            this.width\n        ]);\n        for(l = lights - 1; l >= 0; l--){\n            light = scene.lights[l];\n            this.setBufferData(l, this.program.uniforms.lightPosition, light.position);\n            this.setBufferData(l, this.program.uniforms.lightAmbient, light.ambient.rgba);\n            this.setBufferData(l, this.program.uniforms.lightDiffuse, light.diffuse.rgba);\n        }\n        // Update uniforms\n        for(uniform in this.program.uniforms){\n            buffer = this.program.uniforms[uniform];\n            location = buffer.location;\n            data = buffer.data;\n            switch(buffer.structure){\n                case \"3f\":\n                    this.gl.uniform3f(location, data[0], data[1], data[2]);\n                    break;\n                case \"3fv\":\n                    this.gl.uniform3fv(location, data);\n                    break;\n                case \"4fv\":\n                    this.gl.uniform4fv(location, data);\n                    break;\n            }\n        }\n    }\n    // Draw those lovely triangles\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, this.vertices);\n    return this;\n};\nFSS.WebGLRenderer.prototype.setBufferData = function(index, buffer, value) {\n    if (FSS.Utils.isNumber(value)) {\n        buffer.data[index * buffer.size] = value;\n    } else {\n        for(var i = value.length - 1; i >= 0; i--){\n            buffer.data[index * buffer.size + i] = value[i];\n        }\n    }\n};\n/**\n * Concepts taken from three.js WebGLRenderer\n * @see https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js\n */ FSS.WebGLRenderer.prototype.buildProgram = function(lights) {\n    if (this.unsupported) return;\n    // Create shader source\n    var vs = FSS.WebGLRenderer.VS(lights);\n    var fs = FSS.WebGLRenderer.FS(lights);\n    // Derive the shader fingerprint\n    var code = vs + fs;\n    // Check if the program has already been compiled\n    if (!!this.program && this.program.code === code) return;\n    // Create the program and shaders\n    var program = this.gl.createProgram();\n    var vertexShader = this.buildShader(this.gl.VERTEX_SHADER, vs);\n    var fragmentShader = this.buildShader(this.gl.FRAGMENT_SHADER, fs);\n    // Attach an link the shader\n    this.gl.attachShader(program, vertexShader);\n    this.gl.attachShader(program, fragmentShader);\n    this.gl.linkProgram(program);\n    // Add error handling\n    if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {\n        var error = this.gl.getError();\n        var status = this.gl.getProgramParameter(program, this.gl.VALIDATE_STATUS);\n        console.error(\"Could not initialise shader.\\nVALIDATE_STATUS: \" + status + \"\\nERROR: \" + error);\n        return null;\n    }\n    // Delete the shader\n    this.gl.deleteShader(fragmentShader);\n    this.gl.deleteShader(vertexShader);\n    // Set the program code\n    program.code = code;\n    // Add the program attributes\n    program.attributes = {\n        side: this.buildBuffer(program, \"attribute\", \"aSide\", 1, \"f\"),\n        position: this.buildBuffer(program, \"attribute\", \"aPosition\", 3, \"v3\"),\n        centroid: this.buildBuffer(program, \"attribute\", \"aCentroid\", 3, \"v3\"),\n        normal: this.buildBuffer(program, \"attribute\", \"aNormal\", 3, \"v3\"),\n        ambient: this.buildBuffer(program, \"attribute\", \"aAmbient\", 4, \"v4\"),\n        diffuse: this.buildBuffer(program, \"attribute\", \"aDiffuse\", 4, \"v4\")\n    };\n    // Add the program uniforms\n    program.uniforms = {\n        resolution: this.buildBuffer(program, \"uniform\", \"uResolution\", 3, \"3f\", 1),\n        lightPosition: this.buildBuffer(program, \"uniform\", \"uLightPosition\", 3, \"3fv\", lights),\n        lightAmbient: this.buildBuffer(program, \"uniform\", \"uLightAmbient\", 4, \"4fv\", lights),\n        lightDiffuse: this.buildBuffer(program, \"uniform\", \"uLightDiffuse\", 4, \"4fv\", lights)\n    };\n    // Set the renderer program\n    this.program = program;\n    // Enable program\n    this.gl.useProgram(this.program);\n    // Return the program\n    return program;\n};\nFSS.WebGLRenderer.prototype.buildShader = function(type, source) {\n    if (this.unsupported) return;\n    // Create and compile shader\n    var shader = this.gl.createShader(type);\n    this.gl.shaderSource(shader, source);\n    this.gl.compileShader(shader);\n    // Add error handling\n    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n        console.error(this.gl.getShaderInfoLog(shader));\n        return null;\n    }\n    // Return the shader\n    return shader;\n};\nFSS.WebGLRenderer.prototype.buildBuffer = function(program, type, identifier, size, structure, count) {\n    var buffer = {\n        buffer: this.gl.createBuffer(),\n        size: size,\n        structure: structure,\n        data: null\n    };\n    // Set the location\n    switch(type){\n        case \"attribute\":\n            buffer.location = this.gl.getAttribLocation(program, identifier);\n            break;\n        case \"uniform\":\n            buffer.location = this.gl.getUniformLocation(program, identifier);\n            break;\n    }\n    // Create the buffer if count is provided\n    if (!!count) {\n        buffer.data = new FSS.Array(count * size);\n    }\n    // Return the buffer\n    return buffer;\n};\nFSS.WebGLRenderer.VS = function(lights) {\n    var shader = [\n        // Precision\n        \"precision mediump float;\",\n        // Lights\n        \"#define LIGHTS \" + lights,\n        // Attributes\n        \"attribute float aSide;\",\n        \"attribute vec3 aPosition;\",\n        \"attribute vec3 aCentroid;\",\n        \"attribute vec3 aNormal;\",\n        \"attribute vec4 aAmbient;\",\n        \"attribute vec4 aDiffuse;\",\n        // Uniforms\n        \"uniform vec3 uResolution;\",\n        \"uniform vec3 uLightPosition[LIGHTS];\",\n        \"uniform vec4 uLightAmbient[LIGHTS];\",\n        \"uniform vec4 uLightDiffuse[LIGHTS];\",\n        // Varyings\n        \"varying vec4 vColor;\",\n        // Main\n        \"void main() {\",\n        // Create color\n        \"vColor = vec4(0.0);\",\n        // Calculate the vertex position\n        \"vec3 position = aPosition / uResolution * 2.0;\",\n        // Iterate through lights\n        \"for (int i = 0; i < LIGHTS; i++) {\",\n        \"vec3 lightPosition = uLightPosition[i];\",\n        \"vec4 lightAmbient = uLightAmbient[i];\",\n        \"vec4 lightDiffuse = uLightDiffuse[i];\",\n        // Calculate illuminance\n        \"vec3 ray = normalize(lightPosition - aCentroid);\",\n        \"float illuminance = dot(aNormal, ray);\",\n        \"if (aSide == 0.0) {\",\n        \"illuminance = max(illuminance, 0.0);\",\n        \"} else if (aSide == 1.0) {\",\n        \"illuminance = abs(min(illuminance, 0.0));\",\n        \"} else if (aSide == 2.0) {\",\n        \"illuminance = max(abs(illuminance), 0.0);\",\n        \"}\",\n        // Calculate ambient light\n        \"vColor += aAmbient * lightAmbient;\",\n        // Calculate diffuse light\n        \"vColor += aDiffuse * lightDiffuse * illuminance;\",\n        \"}\",\n        // Clamp color\n        \"vColor = clamp(vColor, 0.0, 1.0);\",\n        // Set gl_Position\n        \"gl_Position = vec4(position, 1.0);\",\n        \"}\"\n    ].join(\"\\n\");\n    return shader;\n};\nFSS.WebGLRenderer.FS = function(lights) {\n    var shader = [\n        // Precision\n        \"precision mediump float;\",\n        // Varyings\n        \"varying vec4 vColor;\",\n        // Main\n        \"void main() {\",\n        // Set gl_FragColor\n        \"gl_FragColor = vColor;\",\n        \"}\"\n    ].join(\"\\n\");\n    return shader;\n};\n/**\n * @class SVG Renderer\n * @author Matthew Wagerfield\n */ FSS.SVGRenderer = function() {\n    FSS.Renderer.call(this);\n    this.element = document.createElementNS(FSS.SVGNS, \"svg\");\n    this.element.setAttribute(\"xmlns\", FSS.SVGNS);\n    this.element.setAttribute(\"version\", \"1.1\");\n    this.element.style.display = \"block\";\n    this.setSize(300, 150);\n};\nFSS.SVGRenderer.prototype = Object.create(FSS.Renderer.prototype);\nFSS.SVGRenderer.prototype.setSize = function(width, height) {\n    FSS.Renderer.prototype.setSize.call(this, width, height);\n    this.element.setAttribute(\"width\", width);\n    this.element.setAttribute(\"height\", height);\n    return this;\n};\nFSS.SVGRenderer.prototype.clear = function() {\n    FSS.Renderer.prototype.clear.call(this);\n    for(var i = this.element.childNodes.length - 1; i >= 0; i--){\n        this.element.removeChild(this.element.childNodes[i]);\n    }\n    return this;\n};\nFSS.SVGRenderer.prototype.render = function(scene) {\n    FSS.Renderer.prototype.render.call(this, scene);\n    var m, mesh, t, triangle, points, style;\n    // Update Meshes\n    for(m = scene.meshes.length - 1; m >= 0; m--){\n        mesh = scene.meshes[m];\n        if (mesh.visible) {\n            mesh.update(scene.lights, true);\n            // Render Triangles\n            for(t = mesh.geometry.triangles.length - 1; t >= 0; t--){\n                triangle = mesh.geometry.triangles[t];\n                if (triangle.polygon.parentNode !== this.element) {\n                    this.element.appendChild(triangle.polygon);\n                }\n                points = this.formatPoint(triangle.a) + \" \";\n                points += this.formatPoint(triangle.b) + \" \";\n                points += this.formatPoint(triangle.c);\n                style = this.formatStyle(triangle.color.format());\n                triangle.polygon.setAttributeNS(null, \"points\", points);\n                triangle.polygon.setAttributeNS(null, \"style\", style);\n            }\n        }\n    }\n    return this;\n};\nFSS.SVGRenderer.prototype.formatPoint = function(vertex) {\n    return vertex.position[0] + \",\" + vertex.position[1];\n};\nFSS.SVGRenderer.prototype.formatStyle = function(color) {\n    var style = \"fill:\" + color + \";\";\n    style += \"stroke:\" + color + \";\";\n    return style;\n};\nexport default FSS;\n","var _typeof = function(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nimport _objectSpread from \"reshow-runtime/es/helpers/objectSpread2\";\nimport FSS from \"./fss.mjs\";\nvar WEBGL = \"webgl\";\nvar CANVAS = \"canvas\";\nvar SVG = \"svg\";\nvar FSS_Worker = function FSS_Worker(opt1, element) {\n    var initialise = function initialise() {\n        createRenderer();\n        createScene();\n        createMesh();\n        createLights();\n        addEventListeners();\n        resize(container.offsetWidth, container.offsetHeight);\n        animate();\n    };\n    var createRenderer = function createRenderer() {\n        if (renderer) {\n        /* output.removeChild(renderer.element); */ }\n        switch(RENDER.renderer){\n            case WEBGL:\n                renderer = new FSS.WebGLRenderer();\n                break;\n            case CANVAS:\n                renderer = new FSS.CanvasRenderer();\n                break;\n            case SVG:\n                renderer = new FSS.SVGRenderer();\n                break;\n        }\n        renderer.setSize(container.offsetWidth, container.offsetHeight);\n        container.insertBefore(renderer.element, null);\n        var style = window.getComputedStyle(self);\n        if (style.getPropertyValue(\"position\") == \"static\" || style.getPropertyValue(\"position\").length == 0) {\n            self.style.position = \"relative\";\n        }\n    };\n    var createScene = function createScene() {\n        scene = new FSS.Scene();\n        scene.VERTEX = VERTEX;\n        scene.LINE = LINE;\n        scene.MESH = MESH;\n    };\n    var createMesh = function createMesh() {\n        scene.remove(mesh);\n        renderer.clear();\n        geometry = new FSS.Plane(MESH.width * renderer.width, MESH.height * renderer.height, MESH.columns, MESH.rows);\n        material = new FSS.Material(MESH.ambient, MESH.diffuse);\n        mesh = new FSS.Mesh(geometry, material);\n        scene.add(mesh);\n        // Augment vertices for animation\n        var v, vertex;\n        for(v = geometry.vertices.length - 1; v >= 0; v--){\n            vertex = geometry.vertices[v];\n            vertex.anchor = FSS.Vector3.floor(FSS.Vector3.clone(vertex.position));\n            vertex.step = FSS.Vector3.create(Math.randomInRange(0.2, 1.0), Math.randomInRange(0.2, 1.0), Math.randomInRange(0.2, 1.0));\n            vertex.time = Math.randomInRange(0, Math.PIM2);\n        }\n    };\n    var createLights = function createLights() {\n        var l, light;\n        for(l = scene.lights.length - 1; l >= 0; l--){\n            light = scene.lights[l];\n            scene.remove(light);\n        }\n        renderer.clear();\n        for(l = 0; l < LIGHT.length; l++){\n            for(var u = 0; u < LIGHT[l].count; u++){\n                light = new FSS.Light(LIGHT[l].ambient, LIGHT[l].diffuse);\n                scene.add(light);\n                // Augment light for animation\n                light.mass = Math.randomInRange(0.5, 1);\n                light.velocity = FSS.Vector3.create();\n                light.acceleration = FSS.Vector3.create();\n                light.force = FSS.Vector3.create();\n                // Ring SVG Circle\n                light.ring = document.createElementNS(FSS.SVGNS, \"circle\");\n                light.ring.setAttributeNS(null, \"stroke\", light.ambient);\n                light.ring.setAttributeNS(null, \"stroke-width\", \"0.5\");\n                light.ring.setAttributeNS(null, \"fill\", \"none\");\n                light.ring.setAttributeNS(null, \"r\", \"10\");\n                // Core SVG Circle\n                light.core = document.createElementNS(FSS.SVGNS, \"circle\");\n                light.core.setAttributeNS(null, \"fill\", light.diffuseHex);\n                light.core.setAttributeNS(null, \"r\", \"4\");\n            }\n        }\n    };\n    var update = function update() {\n        var ox, oy, oz, light, v, vertex, offset = MESH.depth / 2;\n        var light_index = 0;\n        var render_vector = FSS.Vector3.floor(FSS.Vector3.create(renderer.halfWidth, renderer.halfHeight, 0));\n        // Animate Lights\n        for(var l = 0; l < LIGHT.length; l++){\n            for(var i = 0; i < LIGHT[l].count; i++){\n                light = scene.lights[light_index];\n                // Update Bounds\n                FSS.Vector3.copy(LIGHT[l].bounds, center);\n                FSS.Vector3.multiplyScalar(LIGHT[l].bounds, LIGHT[l].xyScalar);\n                // Update Attractor\n                FSS.Vector3.setZ(attractor, LIGHT[l].zOffset);\n                // Overwrite the Attractor position\n                if (LIGHT[l].autopilot && typeof LIGHT[l].position === \"undefined\") {\n                    ox = Math.sin(LIGHT[l].step[0] * now * LIGHT[l].speed);\n                    oy = Math.cos(LIGHT[l].step[1] * now * LIGHT[l].speed);\n                    FSS.Vector3.set(attractor, LIGHT[l].bounds[0] * ox, LIGHT[l].bounds[1] * oy, LIGHT[l].zOffset);\n                }\n                // Reset the z position of the light\n                FSS.Vector3.setZ(light.position, LIGHT[l].zOffset);\n                if (typeof LIGHT[l].position !== \"undefined\") {\n                    FSS.Vector3.set(light.position);\n                    FSS.Vector3.add(light.position, FSS.Vector3.create(LIGHT[l].position[0], LIGHT[l].position[1], LIGHT[l].zOffset));\n                } else {\n                    // Calculate the force Luke!\n                    var D = Math.clamp(FSS.Vector3.distanceSquared(light.position, attractor), LIGHT[l].minDistance, LIGHT[l].maxDistance);\n                    var F = LIGHT[l].gravity * light.mass / D;\n                    FSS.Vector3.subtractVectors(light.force, attractor, light.position);\n                    FSS.Vector3.normalise(light.force);\n                    FSS.Vector3.multiplyScalar(light.force, F);\n                    // Update the light position\n                    FSS.Vector3.set(light.acceleration);\n                    FSS.Vector3.add(light.acceleration, light.force);\n                    FSS.Vector3.add(light.velocity, light.acceleration);\n                    FSS.Vector3.multiplyScalar(light.velocity, LIGHT[l].dampening);\n                    FSS.Vector3.limit(light.velocity, LIGHT[l].minLimit, LIGHT[l].maxLimit);\n                    FSS.Vector3.add(light.position, light.velocity);\n                }\n                light_index++;\n            }\n        }\n        // Animate Vertices\n        for(v = geometry.vertices.length - 1; v >= 0; v--){\n            vertex = geometry.vertices[v];\n            ox = Math.sin(vertex.time + vertex.step[0] * now * MESH.speed);\n            oy = Math.cos(vertex.time + vertex.step[1] * now * MESH.speed);\n            oz = Math.sin(vertex.time + vertex.step[2] * now * MESH.speed);\n            vertex.position = FSS.Vector3.create(MESH.xRange * geometry.segmentWidth * ox, MESH.yRange * geometry.sliceHeight * oy, MESH.zRange * offset * oz - offset);\n            if (MESH.positionFloor === true) {\n                vertex.position = FSS.Vector3.floor(vertex.position);\n            }\n            FSS.Vector3.add(vertex.position, vertex.anchor);\n            FSS.Vector3.add(vertex.position, render_vector);\n        }\n        // Set the Geometry to dirty\n        geometry.dirty = true;\n    };\n    var render = function render() {\n        renderer.render(scene);\n        // Draw Lights\n        if (LIGHT.draw) {\n            var l, lx, ly, light;\n            for(l = scene.lights.length - 1; l >= 0; l--){\n                light = scene.lights[l];\n                lx = light.position[0];\n                ly = light.position[1];\n                switch(RENDER.renderer){\n                    case CANVAS:\n                        renderer.context.lineWidth = 0.5;\n                        renderer.context.beginPath();\n                        renderer.context.arc(lx, ly, 10, 0, Math.PIM2);\n                        renderer.context.strokeStyle = light.ambient;\n                        renderer.context.stroke();\n                        renderer.context.beginPath();\n                        renderer.context.arc(lx, ly, 4, 0, Math.PIM2);\n                        renderer.context.fillStyle = light.diffuse;\n                        renderer.context.fill();\n                        break;\n                    case SVG:\n                        /* lx += renderer.halfWidth; */ /* ly = renderer.halfHeight - ly; */ light.core.setAttributeNS(null, \"fill\", light.diffuse);\n                        light.core.setAttributeNS(null, \"cx\", lx);\n                        light.core.setAttributeNS(null, \"cy\", ly);\n                        renderer.element.appendChild(light.core);\n                        light.ring.setAttributeNS(null, \"stroke\", light.ambient);\n                        light.ring.setAttributeNS(null, \"cx\", lx);\n                        light.ring.setAttributeNS(null, \"cy\", ly);\n                        renderer.element.appendChild(light.ring);\n                        break;\n                }\n            }\n        }\n        MESH.onRender(scene, renderer.context);\n    };\n    var addEventListeners = function addEventListeners() {\n        if (window.attachEvent) {\n            window.addEventHandler = window.attachEvent;\n        }\n        window.addEventListener(\"resize\", onWindowResize, false);\n        self.addEventListener(\"click\", onMouseClick, false);\n        self.addEventListener(\"mousemove\", onMouseMove, true);\n    };\n    var onMouseClick = //------------------------------\n    // Callbacks\n    //------------------------------\n    function onMouseClick(event) {\n        FSS.Vector3.set(attractor, event.x, event.y);\n        /* FSS.Vector3.subtract(attractor, center); */ LIGHT.autopilot = !LIGHT.autopilot;\n    };\n    var onMouseMove = function onMouseMove(event) {\n        FSS.Vector3.set(attractor, event.x, event.y);\n    /* FSS.Vector3.subtract(attractor, center); */ };\n    var onWindowResize = function onWindowResize(event) {\n        resize(self.offsetWidth, self.offsetHeight);\n        render();\n    };\n    var isRun = opt1.autoStart;\n    var timer;\n    var self = element;\n    opt1 = opt1 || {};\n    var MESH = {}, LIGHT = [\n        {}\n    ], VERTEX = {}, LINE = {};\n    //------------------------------\n    // Mesh Properties\n    //------------------------------\n    var mesh_default = {\n        width: 1.2,\n        height: 1.2,\n        depth: 10,\n        columns: undefined,\n        columns_auto: true,\n        rows: undefined,\n        rows_auto: true,\n        zoom: 1,\n        xRange: 0.8,\n        yRange: 0.1,\n        zRange: 1.0,\n        ambient: \"rgba(85, 85, 85, 1)\",\n        diffuse: \"rgba(255, 255, 255, 1)\",\n        background: \"rgb(255, 255, 255)\",\n        speed: 0.0002,\n        fluctuationSpeed: 0.5,\n        fluctuationIntensity: 0,\n        onRender: function onRender() {},\n        floorPosition: false,\n        draw: true\n    };\n    var vertex_default = {\n        radius: 0,\n        fill: \"rgba(0, 0, 0, 0)\",\n        fluctuationSpeed: 0.5,\n        fluctuationIntensity: 0,\n        strokeWidth: 0,\n        strokeColor: \"rgba(0, 0, 0, 0)\",\n        draw: false\n    };\n    var line_default = {\n        fill: \"rgba(0, 0, 0, 0)\",\n        thickness: 1,\n        fluctuationIntensity: 0,\n        fluctuationSpeed: 0.5,\n        draw: false\n    };\n    //------------------------------\n    // Light Properties\n    //------------------------------\n    var light_default = {\n        count: 1,\n        xyScalar: 1,\n        zOffset: 100,\n        ambient: \"rgba(255,0,102, 1)\",\n        diffuse: \"rgba(255,136,0, 1)\",\n        speed: 0.01,\n        gravity: 1200,\n        dampening: 0.95,\n        minLimit: 10,\n        maxLimit: null,\n        minDistance: 20,\n        maxDistance: 400,\n        autopilot: false,\n        draw: false,\n        //show circle\n        bounds: FSS.Vector3.create(),\n        step: FSS.Vector3.create(Math.randomInRange(0.2, 1.0), Math.randomInRange(0.2, 1.0), Math.randomInRange(0.2, 1.0))\n    };\n    var createValues = function createValues(opt) {\n        opt.mesh = opt.mesh || MESH;\n        opt.lights = opt.lights || LIGHT;\n        opt.vertex = opt.vertex || VERTEX;\n        opt.line = opt.line || LINE;\n        MESH = _objectSpread(_objectSpread(_objectSpread({}, mesh_default), MESH), opt.mesh);\n        VERTEX = _objectSpread(_objectSpread(_objectSpread({}, vertex_default), VERTEX), opt.vertex);\n        LINE = _objectSpread(_objectSpread(_objectSpread({}, line_default), LINE), opt.line);\n        for(var i = 0; i < LIGHT.length; i++){\n            LIGHT[i] = _objectSpread(_objectSpread(_objectSpread({}, light_default), LIGHT[i]), opt.lights[i]);\n        }\n        MESH.columns_auto = typeof opt.mesh.columns === \"undefined\";\n        MESH.rows_auto = typeof opt.mesh.rows === \"undefined\";\n    };\n    createValues(opt1);\n    var container = document.createElement(\"div\");\n    container.style.position = \"absolute\";\n    container.style.left = \"0\";\n    container.style.right = \"0\";\n    container.style.top = \"0\";\n    container.style.bottom = \"0\";\n    container.style.background = MESH.background;\n    container.style.zIndex = \"-100\";\n    container.setAttribute(\"class\", \"fss-output\");\n    self.insertBefore(container, null);\n    //------------------------------\n    // Render Properties\n    //------------------------------\n    var RENDER = {\n        renderer: CANVAS\n    };\n    //------------------------------\n    // UI Properties\n    //------------------------------\n    var UI = {\n        show: true\n    };\n    //------------------------------\n    // Global Properties\n    //------------------------------\n    var start = Date.now();\n    var now;\n    var center = FSS.Vector3.create();\n    var attractor = FSS.Vector3.create();\n    var renderer, scene, mesh, geometry, material;\n    var gui, autopilotController;\n    //------------------------------\n    // Methods\n    //------------------------------\n    var resize = function resize(width, height) {\n        if (typeof width == \"undefined\" || (typeof width === \"undefined\" ? \"undefined\" : _typeof(width)) === undefined) {\n            width = self.width();\n        }\n        if (typeof height == \"undefined\" || (typeof height === \"undefined\" ? \"undefined\" : _typeof(height)) === undefined) {\n            height = self.height();\n        }\n        var ratio_x = width / 1000;\n        var ratio_y = height / 1000;\n        var x_tiles = Math.round(ratio_x * 10) * MESH.zoom;\n        var y_tiles = Math.round(ratio_y * 10) * MESH.zoom;\n        MESH.columns = MESH.columns_auto === true ? x_tiles : MESH.columns;\n        MESH.rows = MESH.rows_auto === true ? y_tiles : MESH.rows;\n        renderer.setSize(width, height);\n        FSS.Vector3.set(center, renderer.halfWidth, renderer.halfHeight);\n        createMesh();\n    };\n    function animate() {\n        now = Date.now() - start;\n        update();\n        render();\n        if (isRun) {\n            // requestAnimationFrame(animate);\n            clearTimeout(timer);\n            timer = setTimeout(function() {\n                return animate();\n            }, 150);\n        } else {\n            clearTimeout(timer);\n        }\n    }\n    // Let there be light!\n    initialise();\n    return {\n        start: function start() {\n            if (!isRun) {\n                isRun = true;\n                animate();\n            }\n        },\n        stop: function stop() {\n            isRun = false;\n        }\n    };\n};\nexport default FSS_Worker;\n","// Default\nexport { default } from \"./ui/organisms/GeometryAngle.mjs\";\n","import React, { useImperativeHandle, forwardRef, useRef, useEffect, useMemo } from \"react\";\nimport FssWorker from \"../../fss_worker.mjs\";\nimport fss from \"../../fss.mjs\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar defaultVertex = {\n    // Radius of vertice circle.\n    radius: 2,\n    fill: \"rgba(255, 255, 255, 0.3)\",\n    // Fluctuates opacity of vertex.\n    fluctuationSpeed: 1,\n    fluctuationIntensity: 0.5,\n    strokeWidth: 0.001,\n    strokeColor: \"rgba(0, 104, 149, 1)\",\n    // Instead of setting alpha channel to zero\n    // Set draw to false to avoid computing.\n    draw: false\n};\nvar defaultLine = {\n    fill: \"rgba(255, 255, 255, 0.1)\",\n    thickness: 0,\n    fluctuationIntensity: 0,\n    fluctuationSpeed: 0,\n    draw: false\n};\nvar defaultMesh = {\n    width: 1.6,\n    height: 1.5,\n    // How far should the mesh vary into z-space.\n    depth: 6,\n    // Number of columns for the mesh.\n    columns: undefined,\n    columns_auto: true,\n    // Number of rows for the mesh.\n    rows: undefined,\n    rows_auto: true,\n    zoom: 1,\n    xRange: 0.4,\n    yRange: 0.2,\n    zRange: 8.0,\n    ambient: \"rgba(45, 69, 90, 0.8)\",\n    diffuse: \"rgba(149, 149, 149, 0.43)\",\n    background: \"rgba(92, 121, 117, 1)\",\n    //main color\n    // background: 'rgba(46, 213, 219, 1)'\n    speed: 0.0008,\n    fluctuationSpeed: 0.5,\n    fluctuationIntensity: 0,\n    onRender: function onRender() {},\n    floorPosition: false,\n    draw: true\n};\nvar defaultLights = {\n    // How many light sources belong to this light.\n    count: 0,\n    xyScalar: 0,\n    // Position of light source.\n    zOffset: 0,\n    // ambient: 'rgba(0, 104, 149, 1)',\n    // diffuse: 'rgba(0, 104, 149, 1)',\n    speed: 0,\n    gravity: 0,\n    // Dampening of light's movements.\n    dampening: 0,\n    minLimit: 0,\n    maxLimit: null,\n    minDistance: 20,\n    maxDistance: 400,\n    autopilot: false,\n    draw: false,\n    //show circle\n    bounds: fss.Vector3.create(),\n    step: fss.Vector3.create(Math.randomInRange(0.2, 1.0), Math.randomInRange(0.2, 1.0), Math.randomInRange(0.2, 1.0))\n};\nvar GeometryAngle = /*#__PURE__*/ forwardRef(function(_ref, ref) {\n    var _vertex = _ref.vertex, vertex = _vertex === void 0 ? defaultVertex : _vertex, _line = _ref.line, line = _line === void 0 ? defaultLine : _line, _mesh = _ref.mesh, mesh = _mesh === void 0 ? defaultMesh : _mesh, _lights = _ref.lights, lights = _lights === void 0 ? defaultLights : _lights, _autoStart = _ref.autoStart, autoStart = _autoStart === void 0 ? true : _autoStart;\n    var lastDom = useRef();\n    var lastFss = useRef();\n    var expose = {\n        start: function start() {\n            return lastFss.current.start();\n        },\n        stop: function stop() {\n            return lastFss.current.stop();\n        }\n    };\n    useImperativeHandle(ref, function() {\n        return expose;\n    }, []);\n    useEffect(function() {\n        lastFss.current = FssWorker({\n            vertex: vertex,\n            line: line,\n            mesh: mesh,\n            lights: lights,\n            autoStart: autoStart\n        }, lastDom.current);\n        return function() {\n            expose.stop();\n        };\n    }, []);\n    return useMemo(function() {\n        return /*#__PURE__*/ _jsx(\"div\", {\n            ref: lastDom,\n            style: Styles.container\n        });\n    }, []);\n});\nGeometryAngle.displayName = \"GeometryAngle\";\nexport default GeometryAngle;\nvar Styles = {\n    container: {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n    }\n};\n\n\nconst $ReactRefreshModuleId$ = __webpack_require__.$Refresh$.moduleId;\n    const $ReactRefreshCurrentExports$ = __react_refresh_utils__.getModuleExports(\n      $ReactRefreshModuleId$\n    );\n    function $ReactRefreshModuleRuntime$(exports) {\n      if (import.meta.webpackHot) {\n        let errorOverlay;\n        if (typeof __react_refresh_error_overlay__ !== 'undefined') {\n          errorOverlay = __react_refresh_error_overlay__;\n        }\n        let testMode;\n        if (typeof __react_refresh_test__ !== 'undefined') {\n          testMode = __react_refresh_test__;\n        }\n        return __react_refresh_utils__.executeRuntime(\n          exports,\n          $ReactRefreshModuleId$,\n          import.meta.webpackHot,\n          errorOverlay,\n          testMode\n        );\n      }\n    }\n    if (typeof Promise !== 'undefined' && $ReactRefreshCurrentExports$ instanceof Promise) {\n      $ReactRefreshCurrentExports$.then($ReactRefreshModuleRuntime$);\n    } else {\n      $ReactRefreshModuleRuntime$($ReactRefreshCurrentExports$);\n   }","import _classCallCheck from \"reshow-runtime/es/helpers/classCallCheck\";\nimport _createClass from \"reshow-runtime/es/helpers/createClass\";\nimport _assertThisInitialized from \"reshow-runtime/es/helpers/assertThisInitialized\";\nimport _inherits from \"reshow-runtime/es/helpers/inherits\";\nimport _createSuper from \"reshow-runtime/es/helpers/createSuper\";\nimport _defineProperty from \"reshow-runtime/es/helpers/defineProperty\";\nimport React, { Component } from \"react\";\n/**\n * Production please use\n * import GeometryAngle from 'organism-react-geometryangle';\n */ import GeometryAngle from \"../../index.mjs\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nvar Index = /*#__PURE__*/ function(_Component) {\n    _inherits(Index1, _Component);\n    var _super = _createSuper(Index1);\n    function Index1() {\n        var _this;\n        _classCallCheck(this, Index1);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _super.call.apply(_super, [\n            this\n        ].concat(args));\n        _defineProperty(_assertThisInitialized(_this), \"handleStart\", function() {\n            _this.el.start();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"handleStop\", function() {\n            _this.el.stop();\n        });\n        return _this;\n    }\n    _createClass(Index1, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _this2 = this;\n                return /*#__PURE__*/ _jsxs(\"div\", {\n                    children: [\n                        /*#__PURE__*/ _jsx(GeometryAngle, {\n                            ref: function ref(el) {\n                                return _this2.el = el;\n                            },\n                            autoStart: true\n                        }),\n                        /*#__PURE__*/ _jsx(\"button\", {\n                            style: Styles.button,\n                            onClick: this.handleStart,\n                            children: \"start\"\n                        }),\n                        /*#__PURE__*/ _jsx(\"button\", {\n                            style: Styles.button,\n                            onClick: this.handleStop,\n                            children: \"stop\"\n                        })\n                    ]\n                });\n            }\n        }\n    ]);\n    return Index1;\n}(Component);\nexport default Index;\nvar Styles = {\n    button: {\n        position: \"relative\"\n    }\n};\n\n\nconst $ReactRefreshModuleId$ = __webpack_require__.$Refresh$.moduleId;\n    const $ReactRefreshCurrentExports$ = __react_refresh_utils__.getModuleExports(\n      $ReactRefreshModuleId$\n    );\n    function $ReactRefreshModuleRuntime$(exports) {\n      if (import.meta.webpackHot) {\n        let errorOverlay;\n        if (typeof __react_refresh_error_overlay__ !== 'undefined') {\n          errorOverlay = __react_refresh_error_overlay__;\n        }\n        let testMode;\n        if (typeof __react_refresh_test__ !== 'undefined') {\n          testMode = __react_refresh_test__;\n        }\n        return __react_refresh_utils__.executeRuntime(\n          exports,\n          $ReactRefreshModuleId$,\n          import.meta.webpackHot,\n          errorOverlay,\n          testMode\n        );\n      }\n    }\n    if (typeof Promise !== 'undefined' && $ReactRefreshCurrentExports$ instanceof Promise) {\n      $ReactRefreshCurrentExports$.then($ReactRefreshModuleRuntime$);\n    } else {\n      $ReactRefreshModuleRuntime$($ReactRefreshCurrentExports$);\n   }","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };\n\t__webpack_require__.i.forEach(function(handler) { handler(execOptions); });\n\tmodule = execOptions.module;\n\texecOptions.factory.call(module.exports, module, module.exports, execOptions.require);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// expose the module cache\n__webpack_require__.c = __webpack_module_cache__;\n\n// expose the module execution interceptor\n__webpack_require__.i = [];\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + __webpack_require__.h().slice(0, 7) + \".bundle.js\";\n};","__webpack_require__.h = () => (\"add4b4b496a0fa4e24de\")","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"organism-react-geometryangle:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t};\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"./assets/\";","__webpack_require__.i.push((options) => {\n\tconst originalFactory = options.factory;\n\toptions.factory = function (moduleObject, moduleExports, webpackRequire) {\n\t\t__webpack_require__.$Refresh$.setup(options.id);\n\t\ttry {\n\t\t\toriginalFactory.call(this, moduleObject, moduleExports, webpackRequire);\n\t\t} finally {\n\t\t\tif (typeof Promise !== 'undefined' && moduleObject.exports instanceof Promise) {\n\t\t\t\toptions.module.exports = options.module.exports.then(\n\t\t\t\t\t(result) => {\n\t\t\t\t\t\t__webpack_require__.$Refresh$.cleanup(options.id);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t},\n\t\t\t\t\t(reason) => {\n\t\t\t\t\t\t__webpack_require__.$Refresh$.cleanup(options.id);\n\t\t\t\t\t\treturn Promise.reject(reason);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t__webpack_require__.$Refresh$.cleanup(options.id)\n\t\t\t}\n\t\t}\n\t};\n})\n\n__webpack_require__.$Refresh$ = {\n\tregister: () => (undefined),\n\tsignature: () => ((type) => (type)),\n\truntime: {\n\t\tcreateSignatureFunctionForTransform: () => ((type) => (type)),\n\t\tregister: () => (undefined)\n\t},\n\tsetup: (currentModuleId) => {\n\t\tconst prevModuleId = __webpack_require__.$Refresh$.moduleId;\n\t\tconst prevRegister = __webpack_require__.$Refresh$.register;\n\t\tconst prevSignature = __webpack_require__.$Refresh$.signature;\n\t\tconst prevCleanup = __webpack_require__.$Refresh$.cleanup;\n\n\t\t__webpack_require__.$Refresh$.moduleId = currentModuleId;\n\n\t\t__webpack_require__.$Refresh$.register = (type, id) => {\n\t\t\tconst typeId = currentModuleId + \" \" + id;\n\t\t\t__webpack_require__.$Refresh$.runtime.register(type, typeId);\n\t\t}\n\n\t\t__webpack_require__.$Refresh$.signature = () => (__webpack_require__.$Refresh$.runtime.createSignatureFunctionForTransform());\n\n\t\t__webpack_require__.$Refresh$.cleanup = (cleanupModuleId) => {\n\t\t\tif (currentModuleId === cleanupModuleId) {\n\t\t\t\t__webpack_require__.$Refresh$.moduleId = prevModuleId;\n\t\t\t\t__webpack_require__.$Refresh$.register = prevRegister;\n\t\t\t\t__webpack_require__.$Refresh$.signature = prevSignature;\n\t\t\t\t__webpack_require__.$Refresh$.cleanup = prevCleanup;\n\t\t\t}\n\t\t}\n\t}\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t1: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkorganism_react_geometryangle\"] = self[\"webpackChunkorganism_react_geometryangle\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// module cache are used so entry inlining is disabled\n// startup\n// Load entry module and return exports\n__webpack_require__.O(undefined, [0,2], () => (__webpack_require__(326)))\n__webpack_require__.O(undefined, [0,2], () => (__webpack_require__(327)))\nvar __webpack_exports__ = __webpack_require__.O(undefined, [0,2], () => (__webpack_require__(193)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}